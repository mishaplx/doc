# ОТЧЕТ WORD

в тексте шаблона прописываются команды в фигурных скобках: {команда}

## КОМАНДЫ

### OBJ: `ОБЪЕКТ`
- `название ключа` - читать ключ из объекта obj
- команда: `filter(цепочка команд, val)`
  - отфильтровать данные
  - условие отбора: результат выполнения цепочки команд = val
  - пример: `{#doc.Project.ProjectExec.filter(Stage.name.if(Визировать).+,+)} ... {/}`
- команда: `sort(объект1,ASC,объект2,DESC, ...)`
  - сортировать данные
  - допустима сортировка по нескольким параметрам
  - ключи сортировки могут быть распаршены
  - пример: `{#doc.Project.ProjectExec.sort(Stage.id,ASC} ... {/}`
- команда: `count()`
  - количество элементов в списке obj
- команда: `$index`
  - порядковый элемент в списке obj (с 1)



### OBJ: `ОБЪЕКТ STAFF`
- команда: `fio(full)`
  - сформировать строку: фамилия имя отчество
  - пример: 'Иванов Иван Иванович'
- команда: `fio(short)`
  - сформировать строку: фамилия инициалы
  - пример: 'Иванов И.И.'
- команда: `fio(short_rev)`
  - сформировать строку: инициалы фамилия
  - пример: 'И.И.Иванов'


### OBJ: `СТРОКА`
- команда: `text(val)`
  - установить значение строки в val
  - допускается без команды text, например: `... . (свод). ...`
- команда: `prefix(val)`
  - добавить val перед строкой если строка НЕ ПУСТАЯ
- команда: `postfix(val)`
  - добавить val после строки если строка НЕ ПУСТАЯ
- команда: `space()`
  - добавить пробел если строка НЕ ПУСТАЯ
- команда: `trim()`
  - обрезать по краям пробелы
- команда: `upper()`
  - все символы в заглавные
- команда: `lower()`
  - все символы в строчные
- команда: `props(var_name)`
  - установить значение строки в setting.var_name
  - var_name задается в настройках (реквизиты)


### OBJ / СТРОКА: `ДАТА/ВРЕМЯ`
- команда: `dateformat(...)`
  - формат даты/времени
  - пример: 'dateformat(DD.MM-YYYY)' => '01.01-2000'


### OBJ: `BOOL` / `IF`
- команда: `if(...)` / `IF(...)`
  - if(val): val = obj.toString() - продолжить
  - if(): obj == [undefined, null] - продолжить
    - ранее было: if(null): val = null и obj == [undefined, null] - продолжить
  - if(not_null): val = not_null и obj != [undefined, null] - продолжить
  - иначе - прекратить и вернуть пустую строку
  - после if в продолжение допускается начать просмотр объекта с начала
  - пример: {is_responsible.if(true). (свод)}
  - пример: {is_responsible.if(true).Controller.User.dtc.dateformat.DD*MM*YYYY}
  - пример: {job.Doc.if(not_null).reg_num.prefix(к № )}


## ВАЖНО
- регистр названий объектов имеет значение
- регистр названий команд значения не имеет
- общее правило работы фрейворка: когда парсер объекта возвращает undefined или null, то фрейворк запускает  попытку найти ключ в родительском объекте, не находит, возвращает ошибку. Чтобы не допустить такого поведения, при отсутствии объекта возвращается ''.
- если парсер встречает объект или список объектов, то в объектах проверяются признаки del и temp.
  - При установленном temp - объект исключается из работы
  - При установленном признаке del - проверяется тип Entity-объекта и принимается решение
- при создании справочника проверять актуальность списка Entity-объектов


# ОТЧЕТ EXCEL

для формированая отчета используется ini-файл с одноименным названием шаблона отчета

## INI-ФАЙЛ
- содержит произвольное количество блоков с произволбным названием
- каждый блок описывает одно место вставки

### КЛЮЧИ
- `cell`
  - ячейка в формате 'sheet!A1', куда производится вставка
  - sheet - название листа или порядковый номер (начиная с 1), указывать не обязательно
  - по умолчанию: первый лист, первый столбец, первая строка
  - при вставке областей - столбец всегда 1, независимо от указанного
- `type` - тип блока. Возможные значения: `sql`, `date`

  - для типа `sql`
    - `file` - название sql-файла для получения данных

  - для типа `date`
    - `val` - значение

### ПАРАМЕТРЫ
- в тексте sql-запроса соответствующие сигнатуры заменяются на значения параметров
- это особенно важно при передаче дат: их мы указываем строкой как они должны выглядеть в sql-запросе, например: "2023-01-01 01:01:01". При этом указывается МЕСТНОЕ время.

## ВАЖНО
- при выполнении sql запроса используется отдельное подключение фреймворка pg, т.к. TypeORM не позволяет корректно выполнять сложные скрипты запросов, содержащие транзакции


